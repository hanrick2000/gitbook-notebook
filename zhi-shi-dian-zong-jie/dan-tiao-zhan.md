# 单调栈

## 单调栈

### 什么是单调栈

 所谓的单调栈Monotone Stack，就是栈内元素都是单调递增或者单调递减的，有时候需要严格的单调递增或递减，根据题目的具体情况来看吧。关于单调栈，[这个帖子](https://blog.csdn.net/liujian20150808/article/details/50752861)讲的不错，而且举了个排队的例子来类比。那么，博主也举个生动的例子来说明吧：比如有一天，某家店在发free food，很多人在排队，于是你也赶过去凑热闹。但是由于来晚了，队伍已经很长了，想着不然就插个队啥的。但发现排在队伍最前面的都是一些有纹身的大佬，惹不起，只能赞美道，小猪佩奇身上纹，来世还做社会人。于是往队伍后面走，发现是一群小屁孩，直接全部撵走，然后排在了社会大佬们的后面。那么这就是一个单调递减的栈，按实力递减。由于栈元素是后进先出的，所以上面的例子正确的检查顺序应该是从队尾往前遍历，小屁孩都撵走，直到遇到大佬停止，然后排在大佬后面（假设这个队列已经事先按实力递减排好了）。

### 为什么要用单调栈？

1.  单调栈的一大优势就是**线性的时间复杂度**，所有的元素只会进栈一次，而且一旦出栈后就不会再进来了。
2. **单调递增栈可以找到左起第一个比当前数字小的元素**。比如数组 \[2 1 4 6 5\]，刚开始2入栈，数字1入栈的时候，发现栈顶元素2比较大，将2移出栈，此时1入栈。那么2和1都没左起比自身小的数字。然后数字4入栈的时候，栈顶元素1小于4，于是1就是4左起第一个小的数字。此时栈里有1和4，然后数字6入栈的时候，栈顶元素4小于6，于是4就是6左起第一个小的数字。此时栈里有1，4，6，然后数字5入栈的时候，栈顶元素6大于5，将6移除，此时新的栈顶元素4小于5，那么4就是5左起的第一个小的数字，最终栈内数字为1，4，5。
3. **单调递减栈可以找到左起第一个比当前数字大的元素**。这里就不举例说明了，同样的道理，大家可以自行验证一下。

## Largest Rectangle in Histogram

这里重点说一下我犯错的几个点吧：

（1） 这个地方需要处理最后一个正方形（[Maximal Rectangle](https://leetcode.com/problems/maximal-rectangle/description/) 也需要，[Trapping Rain Water](http://www.cnblogs.com/grandyang/p/4402392.html)则不需要：因为最后一块高地并不能储水）。我们在最后一块的位置上设他为0，就可以直接放入循环中计算（0可以触发任何一个单调栈）

（2）注意每次设定的高是当前的栈顶元素，因为是个递增序列，所以要照顾到元素变小以后的方形面积

```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        Stack<Integer> s = new Stack<>();
        int max = 0, index = 0;
        while(index <= heights.length) {
            int h = (index == heights.length ? 0 : heights[index]);
            if(s.isEmpty() || heights[s.peek()] <= h) {
                s.push(index++);
            } else {
                int top = s.pop();
                max = Math.max(max, heights[top] * (s.isEmpty() ? index : index - s.peek() -1));
            }
        }
        return max;
    }
}

```

## Maximal Rectangle

1. 题目给出的是一个矩阵，其中0和1的位置参差不齐，不好通过遍历得到答案。想到对矩阵进行逐行操作，这样就可以把矩阵再一条边上“对齐”，这样就只用考虑另外一条边上的不同了。用一个与矩阵等长的一维数组（成为h），来记录当前行中，此列里面连续1的个数。
2. 经过第一步的处理以后，要求矩阵1的个数最多，需要尽可能使横向的连续1多，并且对应范围内，h的最小值要尽可能大。和木桶原理很类似。
3. 根据木桶原理的特性，想到了采用单调栈：单调栈可以求当前元素的左边第一个小于他的元素，且时间复杂度是线性的。在这个问题上，因为木桶中能装的水是由最短的那块木板决定的，所以我们先从最高的木板（也就是h的值）开始处理，维护一个递增栈，当元素大于等于当前栈顶元素的时候入栈，否则就开始处理。（这里有个技巧是：我们是需要计算长和宽，所以我选择把下标入栈，这样可以同时记录长和宽）
4. 当前元素小于栈顶元素的时候，对当前栈进行出栈操作，并计算到当前下标时的最大面积，直到栈顶元素小与当前元素。
5. 这样操作会遗漏最后一行的元素，所以循环的时候，对行里面的元素循环的重点，比行的长度大1，最后一个h的值衡为1，这样，每次到达最后一个元素的时候都能保证从头到尾计算这个栈一次，避免计算遗漏。

```java
class Solution {
    public int maximalRectangle(char[][] matrix) {
        if(matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return 0;
        }
        
        int len = matrix.length;
        int col = matrix[0].length;
        int[] h = new int[col+1];
        
        int max = 0;
        
        for(int i=0;i<len;i++) {
            Stack<Integer> s = new Stack<>();
            for(int j=0;j<col;j++) {
              
                if(matrix[i][j] == '1') {
                    h[j]++;
                } else {
                    h[j] = 0;
                }
            
                if(s.isEmpty() || h[s.peek()]<=h[j]) {
                    s.push(j);
                } else {
                     while(!s.isEmpty() && h[j]<h[s.peek()]) {
                         int top = s.pop();
                         max = Math.max(max, h[top]*(s.isEmpty()?j:(j-s.peek()-1)));
                     }
                    s.push(j);
                    }
                    
                }
            }
        return max;
        }
        
    }

```



## 总结

 初步来总结一下单调栈吧，单调栈其实是一个看似原理简单，但是可以变得很难的解法。线性的时间复杂度是其最大的优势，每个数字只进栈并处理一次，而解决问题的核心就在处理这块，当前数字如果破坏了单调性，就会触发处理栈顶元素的操作，而触发数字有时候是解决问题的一部分，比如在[Trapping Rain Water](http://www.cnblogs.com/grandyang/p/4402392.html)中作为右边界。有时候仅仅触发作用，比如在[Largest Rectangle in Histogram](http://www.cnblogs.com/grandyang/p/4322653.html)中是为了开始处理栈顶元素，如果仅作为触发，可能还需要在数组末尾增加了一个专门用于触发的数字。另外需要注意的是，虽然是递增或递减栈，但里面实际存的数字并不一定是递增或递减的，因为我们可以存坐标，而这些坐标带入数组中才会得到递增或递减的数。所以对于玩数组的题，如果相互之间关联很大，那么就可以考虑考虑单调栈能否解题。

